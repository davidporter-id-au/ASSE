#BlueJ class context
comment0.params=s
comment0.target=Engine(Server.ServerSocket)
comment0.text=\n\ Constructor\n\ Please\ note\ that\ the\ ability\ to\ provide\ a\ specified\ socket\ here\ is\ for\ testing\ only.\n\ @param\ \n
comment1.params=
comment1.target=void\ command()
comment1.text=\n\ command\n\ The\ command\ loop,\ wait\ for\ commands\ and\ then\ execute\ them\n
comment10.params=l
comment10.target=void\ setUsage(java.util.AbstractList)
comment10.text=\n\ setUsage\n\ Sets\ the\ usage\ data.\ \n
comment11.params=l
comment11.target=void\ setProduction(java.util.AbstractList)
comment11.text=\n\ setProduction\n\ Sets\ the\ production\ list,\ ie,\ the\ list\ of\ production\ blocks\ of\ power.\ \n
comment12.params=
comment12.target=double\ getPrice()
comment12.text=\n\ getPrice\n\ Provides\ the\ present\ price\ in\ decimal\ form.\ \n\ Will\ throw\ -1\ in\ the\ event\ of\ a\ problem.\ \n
comment13.params=
comment13.target=void\ getCurrentPrice()
comment13.text=\n\ getCurrentPrice\n\ Updates\ the\ current\ operational\ price\ and\ set\ it.\ \n\ \n\ Given\ the\ demonstrative\ nature\ of\ the\ class,\ this\ is\ only\ \n\ creating\ the\ information\ our\ of\ thin\ air.\ In\ reality,\ \n\ it\ ought\ to\ get\ it\ through\ a\ socket\ or\ some\ kind\ of\ \n\ transport\ medium\ from\ the\ provider.\ \n
comment14.params=
comment14.target=void\ updateForecast()
comment14.text=\n\ updateForecast\n\ updates\ the\ forecast\ data\ from\ appliances.\n
comment15.params=
comment15.target=void\ update()
comment15.text=\n\ update\n\ Downloads\ the\ latest\ price\ information\ and\ sets\ it\ accordingly\n\ Note\ that\ this\ command\ may\ be\ invoked\ by\ any\ party,\ including\ the\ \n\ customer.\ It\ does\ require\ a\ valid\ signature,\ but\ does\ \n\ not\ require\ vendor\ appropval\n
comment16.params=
comment16.target=void\ packup()
comment16.text=\n\ packup\n\ Takes\ the\ current\ usage\ block\ and\ packs\ it\ up\ and\ places\ it\ in\ the\ log\n
comment17.params=p
comment17.target=void\ setCurrentPrice(Server.Price)
comment17.text=\n\ setCurrentPrice\n\ Sets\ the\ current\ operation\ price.\ \n
comment18.params=
comment18.target=Server.Command\ listener()
comment18.text=\n\ listener\n\ A\ simulation\ of\ something\ that\ listens\ at\ a\ socket,\ and\ when\ a\ command\ is\ \n\ received,\ passes\ it\ on\ to\ the\ command\ method\n
comment19.params=o
comment19.target=void\ sender(java.lang.Object)
comment19.text=\n\ sender\n\ A\ simulated\ socket.\ Commands\ are\ sent\ through\ this\ to\ be\ theoretically\ dispatched\n\ securely\ to\ the\ server.\ Signed\ on\ the\ fly\ and\ dispatched\ with\ signature.\ \n
comment2.params=c
comment2.target=void\ verifyCommandSignature(Server.Command)
comment2.text=\n\ verifyCommandSignature\n\ Takes\ a\ command\ and\ verifies\ its\ 'key'\ against\ the\ one\ stored\ locally\ to\ determine\ the\ authenticity\ of\ the\ command\n
comment20.params=o
comment20.target=java.lang.String\ encryptSign(java.lang.Object)
comment20.text=\n\ encryptSign\n\ encrypts\ and\ signs\ the\ given\ data.\ In\ this\ case,\ the\ signature\ and\ encryption\n\ is\ given\ simulated\ only.\ \n
comment21.params=c
comment21.target=boolean\ timeCheck(Server.Command)
comment21.text=\n\ timeCheck\n\ a\ method\ that\ checks\ the\ timestamp\ on\ a\ signature\ and\ will\ return\n\ true\ if\ the\ time\ is\ within\ a\ VALIDTIMEFRAME.\ \n\ \n\ As\ of\ version\ 1,\ this\ is\ not\ implemented\ but\ merely\ serves\ as\ an\ example\ of\ \n\ this\ kind\ of\ behaviour.\ At\ the\ present,\ this\ will\ return\ false\ as\ it\ \n\ receives\ an\ invalid\ signature.\ \n
comment22.params=
comment22.target=Server.ServerSocket\ getServer()
comment22.text=\n\ getServer\n\ Returns\ the\ 'server\ socket'.\ Used\ for\ testing\ purposes.\ \n
comment23.params=s
comment23.target=void\ setServer(Server.ServerSocket)
comment23.text=\n\ setServer\n\ allows\ the\ server\ 'socket'\ to\ be\ added.\ This\ is\ necessary\ only\ for\ testing\ and\ would\ be\ removed\n\ in\ a\ production\ system.\ A\ production\ system\ would\ probably\ hardcode\ a\ http\ address.\ \n\ \n\ However,\ even\ with\ this\ being\ open,\ the\ security\ consequences\ are\ intended\ to\ be\ little\ because\n\ all\ server\ input\ is\ considered\ to\ be\ untrusted\ anyway\ and\ will\ always\ be\ verified.\ \n
comment24.params=verbose
comment24.target=java.lang.String\ smDebug(boolean)
comment24.text=\n\ smDebug\n\ returns\ a\ list\ of\ system\ state\ variables\ and\ returns\ this\ as\ a\ string.\n\ This\ would\ not\ exist\ on\ a\ production\ system\ because\ it\ exposes\n\ confidential\ information\ for\ the\ purpose\ of\ validity\ testing.\ \n\ \n\ @param\ verbose\ whether\ or\ not\ to\ include\ large\ amounts\ of\ information\ pertaining\n\ to\ production\n
comment25.params=
comment25.target=java.lang.String\ smDebug()
comment25.text=\n\ smDebug\ -\ Quieter\ mode\n\ starts\ the\ debugger\ in\ non-verbose\ mode\ by\ default\n
comment3.params=
comment3.target=void\ sensorInput()
comment3.text=\n\ sensorInput\n\ Since\ the\ class\ isn't\ using\ concurrency,\ this\ is\ being\ simulated\ by\ a\ loop\ into\ a\ \n\ queue\ here,\ representing\ usage\ over\ time.\ This\ is\ not\ a\ 'real'\ method\ class,\ \n\ rather,\ it\ is\ a\ demonstration\ of\ the\ sensor\ being\ used\ over\ time.\ The\ 5\ here\ is\ an\ \n\ arbirtrary\ demonstrative\ number.\ \n\ \n\ This\ is\ only\ for\ a\ single\ price\ point,\ it\ does\ not\ affect\ the\ creation\ of\ usage\ blocks\n\ since\ they\ will\ only\ change\ when\ there\ is\ a\ change\ in\ price.\ \n\ \n\ Note\ that\ this\ is\ being\ called\ from\ the\ update\ method\ for\ test\ purposes.\ It\ could\ be\ \n\ theoretically\ called\ at\ any\ point\ in\ time\ because\ it\ represents\ the\ quantity\ of\ usage\ \n\ over\ a\ passage\ of\ time.\ However,\ if\ done\ this\ way\ it\ will\ simulate\ data\ usage\n\ over\ price\ changes\ and\ create\ usage\ blocks.\ \n\ \n
comment4.params=
comment4.target=void\ sensorData()
comment4.text=\n\ sensorData\n\ The\ representation\ of\ data\ being\ added\ to\ usage\ records\ as\ it\ is\ detected.\n\ However,\ this\ method\ lacks\ a\ time\ dimension\ and\ would\ typically\ be\ called\n\ concurrently.\ \n
comment5.params=in
comment5.target=void\ addUsage(double)
comment5.text=\n\ addUsage\n\ Adds\ the\ specified\ amount\ of\ power\ to\ the\ present\ block\ of\ usage.\ \n
comment6.params=in
comment6.target=void\ addProduction(double)
comment7.params=
comment7.target=void\ forecast()
comment7.text=\n\ forecast\n\ Sends\ the\ forecast\ data\ for\ applications\ for\ the\ given\ period.\ \n
comment8.params=
comment8.target=void\ usage()
comment8.text=\n\ usage\n\ Sends\ the\ usage\ data.\ \n
comment9.params=
comment9.target=void\ clear()
comment9.text=\n\ clear\ \n\ Clears\ the\ log\ files,\ implicitly\ it\ is\ understood\ that\ coomand\ will\ be\ invoked\ \n\ once\ usage\ data\ has\ been\ sent\ and\ confirmed.\ \n\ Note\ this\ specifies\ a\ vector\ as\ the\ usage\ type.\ However,\ this\ is\ not\ necessary.\ \n
numComments=26
