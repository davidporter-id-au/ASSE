#BlueJ class context
comment0.params=s\ providerKey
comment0.target=Engine(Server.ServerSocket,\ java.lang.String)
comment0.text=\n\ Constructor\n\ Please\ note\ that\ the\ ability\ to\ provide\ a\ specified\ socket\ here\ is\ for\ testing\ only.\n\ @param\ s\ The\ server\ which\ the\ engine\ will\ be\ interacting\ with.\n\ @param\ c\ The\ clinet\ interface\ with\ which\ the\ Smart\ Meter\ Engine\ will\ be\ interacting\ with.\ \n
comment1.params=providerKey
comment1.target=void\ setupKeys(java.lang.String)
comment1.text=\n\ setupKeys\n\ Sets\ the\ keys.\ \n
comment10.params=in
comment10.target=void\ addProduction(double)
comment11.params=
comment11.target=void\ forecast()
comment11.text=\n\ forecast\n\ Sends\ the\ forecast\ data\ for\ applications\ for\ the\ given\ period.\ \n
comment12.params=
comment12.target=void\ usage()
comment12.text=\n\ usage\n\ Sends\ the\ usage\ data.\ \n
comment13.params=
comment13.target=void\ clear()
comment13.text=\n\ clear\ \n\ Clears\ the\ log\ files,\ implicitly\ it\ is\ understood\ that\ coomand\ will\ be\ invoked\ \n\ once\ usage\ data\ has\ been\ sent\ and\ confirmed.\ \n\ Note\ this\ specifies\ a\ vector\ as\ the\ usage\ type.\ However,\ this\ is\ not\ necessary.\ \n
comment14.params=l
comment14.target=void\ setUsage(java.util.AbstractList)
comment14.text=\n\ setUsage\n\ Sets\ the\ usage\ data.\ \n
comment15.params=l
comment15.target=void\ setProduction(java.util.AbstractList)
comment15.text=\n\ setProduction\n\ Sets\ the\ production\ list,\ ie,\ the\ list\ of\ production\ blocks\ of\ power.\ \n
comment16.params=
comment16.target=double\ getPrice()
comment16.text=\n\ getPrice\n\ Provides\ the\ present\ use\ price\ in\ decimal\ form.\ \n\ Will\ throw\ -1\ in\ the\ event\ of\ a\ problem.\ \n
comment17.params=
comment17.target=double\ getFeedInPrice()
comment17.text=\n\ getFeedInPrice\n\ Returns\ the\ feed-in\ price.\ \n
comment18.params=
comment18.target=void\ getCurrentPrice()
comment18.text=\n\ getCurrentPrice\n\ Updates\ the\ current\ operational\ price\ and\ set\ it.\ \n\ \n\ Given\ the\ demonstrative\ nature\ of\ the\ class,\ this\ is\ only\n\ grabbing\ the\ information\ from\ another\ adjacent\ class.\ In\ reality,\ \n\ it\ ought\ to\ get\ it\ through\ a\ socket\ or\ some\ kind\ of\ \n\ transport\ medium\ from\ the\ provider.\ \n\ \n\ This\ is\ demonstrated\ here\ through\ the\ use\ of\ the\ server\ 'socket'\ which\n\ could\ be\ replaced\ with\ an\ actual\ network\ interface.\ \n
comment19.params=
comment19.target=void\ updateForecast()
comment19.text=\n\ updateForecast\n\ updates\ the\ forecast\ data\ from\ appliances.\n
comment2.params=
comment2.target=void\ writeUsageData()
comment2.text=\n\ writeUsageData\n\ Writes\ the\ present\ usage\ data\ to\ a\ file.\ In\ a\ concurrently\ run\ system,\ this\ would\ be\ periodically\n\ updated\ as\ required.\ Here\ the\ periodic\ write\ is\ only\ simulated.\ \n
comment20.params=
comment20.target=void\ update()
comment20.text=\n\ update\n\ Downloads\ the\ latest\ price\ information\ and\ sets\ it\ accordingly\n\ Note\ that\ this\ command\ may\ be\ invoked\ by\ any\ party,\ including\ the\ \n\ customer.\ It\ does\ require\ a\ valid\ signature,\ but\ does\ \n\ not\ require\ vendor\ appropval\n
comment21.params=
comment21.target=void\ packup()
comment21.text=\n\ packup\n\ Takes\ the\ current\ usage\ block\ and\ packs\ it\ up\ and\ places\ it\ in\ the\ log\n
comment22.params=p
comment22.target=void\ setCurrentPrice(Price)
comment22.text=\n\ setCurrentPrice\n\ Sets\ the\ current\ operation\ price.\ \n
comment23.params=
comment23.target=Command\ listener()
comment23.text=\n\ listener\n\ A\ simulation\ of\ something\ that\ listens\ at\ a\ socket,\ and\ when\ a\ command\ is\ \n\ received,\ passes\ it\ on\ to\ the\ command\ method\n
comment24.params=o
comment24.target=void\ sender(java.lang.Object)
comment24.text=\n\ sender\n\ A\ simulated\ socket.\ Commands\ are\ sent\ through\ this\ to\ be\ theoretically\ dispatched\n\ securely\ to\ the\ server.\ Signed\ on\ the\ fly\ and\ dispatched\ with\ signature.\ \n
comment25.params=o
comment25.target=java.lang.String\ encryptSign(java.lang.Object)
comment25.text=\n\ encryptSign\n\ encrypts\ and\ signs\ the\ given\ data.\ In\ this\ case,\ the\ signature\ and\ encryption\n\ is\ given\ simulated\ only.\ \n
comment26.params=d
comment26.target=boolean\ timeCheck(java.util.Date)
comment26.text=\n\ timeCheck\n\ a\ method\ that\ checks\ the\ timestamp\ on\ a\ signature\ and\ will\ return\n\ true\ if\ the\ time\ is\ within\ a\ VALIDTIMEFRAME.\ \n
comment27.params=
comment27.target=double\ netUsage()
comment27.text=\n\ netUsage\n\ A\ calculation\ for\ the\ client\ of\ their\ total\ electricity\ consumption\ given\ in\ dollar\ figures.\n\ Essentially\ performs\ a\ simple\ calculation\ of\ each\ usage\ block\ that\ has\ been\ created\ \n\ multiplied\ by\ the\ price\ at\ that\ block.\ \n
comment28.params=
comment28.target=SmartMeterClient\ getClientInterface()
comment28.text=\n\ getClientInterface\n\ Returns\ an\ interface\ which\ the\ client\ may\ interact\ with.\ \n
comment29.params=
comment29.target=Server.ServerSocket\ getServer()
comment29.text=\n\ getServer\n\ Returns\ the\ 'server\ socket'.\ Used\ for\ testing\ purposes.\ \n
comment3.params=
comment3.target=void\ writeProductionData()
comment3.text=\n\ writeProductionData\n\ Writes\ the\ present\ level\ of\ production\ of\ electricity\ to\ a\ file.\ Similarly\ with\ the\ above\ method,\n\ this\ ought\ to\ be\ run\ periodically\ in\ a\ concurrent\ system.\ \n
comment30.params=s\ providerKey\ v
comment30.target=Engine(Server.ServerSocket,\ java.lang.String,\ boolean)
comment30.text=\n\ debugConstructor\n\ creates\ an\ engine\ which\ operates\ with\ the\ option\ to\ flag\ verbose\ mode\ on.\n
comment31.params=
comment31.target=int\ numberCommandsDebug()
comment31.text=\n\ numberCommandsDebug\n\ A\ simple\ method\ which\ return\ the\ number\ of\ commands\ that\ have\ executed\ since\ the\ \n\ creating\ of\ the\ Smart\ Meter\ Engine\ Object.\ \n
comment32.params=verbose
comment32.target=java.lang.String\ smDebug(boolean)
comment32.text=\n\ smDebug\n\ returns\ a\ list\ of\ system\ state\ variables\ and\ returns\ this\ as\ a\ string.\n\ This\ would\ not\ exist\ on\ a\ production\ system\ because\ it\ exposes\n\ confidential\ information\ for\ the\ purpose\ of\ validity\ testing.\ \n\ \n\ @param\ verbose\ whether\ or\ not\ to\ include\ large\ amounts\ of\ information\ pertaining\n\ to\ production\n
comment33.params=
comment33.target=java.lang.String\ smDebug()
comment33.text=\n\ smDebug\ -\ Quieter\ mode\n\ starts\ the\ debugger\ in\ non-verbose\ mode\ by\ default\n
comment34.params=
comment34.target=double\ smDebug_getPrice()
comment34.text=\n\ smDebug_getPrice\n\ Returns\ the\ current\ price\ value,\ used\ for\ debugging\ purposes\ only.\ \n
comment35.params=e
comment35.target=void\ setClient(Engine)
comment35.text=\n\ setClient\n\ Allows\ the\ client\ interface\ and\ interaction\ to\ be\ simulated\ in\ a\ similar\ manner\ to\ that\ of\n\ the\ server.\ The\ passing\ of\ a\ referece\ to\ itself\ is\ only\ a\ means\ to\ establish\ a\ demonstrative\ \n\ connection.\ \n
comment36.params=s
comment36.target=void\ setServer(Server.ServerSocket)
comment36.text=\n\ setServer\n\ allows\ the\ server\ 'socket'\ to\ be\ added.\ This\ is\ necessary\ only\ for\ testing\ and\ would\ be\ removed\n\ in\ a\ production\ system.\ A\ production\ system\ would\ probably\ hardcode\ a\ http\ address.\ \n\ \n\ However,\ even\ with\ this\ being\ open,\ the\ security\ consequences\ are\ intended\ to\ be\ little\ because\n\ all\ server\ input\ is\ considered\ to\ be\ untrusted\ anyway\ and\ will\ always\ be\ verified.\ \n
comment4.params=
comment4.target=void\ existingUsage()
comment4.text=\n\ existingUsage\n\ Loads\ up\ the\ existing\ usage\ with\ the\ fileHandler\n
comment5.params=
comment5.target=void\ command()
comment5.text=\n\ command\n\ The\ command\ loop,\ wait\ for\ commands\ and\ then\ execute\ them.\n\ \n\ In\ reality,\ this\ method\ would\ be\ a\ private\ thread\ which\ would\ be\ called\n\ in\ the\ event\ of\ a\ notification\ that\ a\ command\ had\ been\ received.\ In\ function\n\ it\ is\ essentially\ the\ same,\ however,\ here\ it\ must\ be\ listed\ as\ public\ for\ debug\ \n\ purposes\ and\ it\ contains\ a\ number\ of\ demonstrative\ methods\ (due\ to\ this\ being\ a\n\ non-concurrent\ system).\ \n
comment6.params=c
comment6.target=void\ verifyCommandSignature(Command)
comment6.text=\n\ verifyCommandSignature\n\ Takes\ a\ command\ and\ verifies\ its\ 'key'\ against\ the\ one\ stored\ locally\ to\ determine\ the\ authenticity\ of\ the\ command\n
comment7.params=
comment7.target=void\ sensorInput()
comment7.text=\n\ sensorInput\n\ Since\ the\ class\ isn't\ using\ concurrency,\ this\ is\ being\ simulated\ by\ a\ loop\ into\ a\ \n\ queue\ here,\ representing\ usage\ over\ time.\ This\ is\ not\ a\ 'real'\ method\ class,\ \n\ rather,\ it\ is\ a\ demonstration\ of\ the\ sensor\ being\ used\ over\ time.\ The\ 5\ here\ is\ an\ \n\ arbirtrary\ demonstrative\ number.\ \n\ \n\ This\ is\ only\ for\ a\ single\ price\ point,\ it\ does\ not\ affect\ the\ creation\ of\ usage\ blocks\n\ since\ they\ will\ only\ change\ when\ there\ is\ a\ change\ in\ price.\ \n\ \n\ Note\ that\ this\ is\ being\ called\ from\ the\ update\ method\ for\ test\ purposes.\ It\ could\ be\ \n\ theoretically\ called\ at\ any\ point\ in\ time\ because\ it\ represents\ the\ quantity\ of\ usage\ \n\ over\ a\ passage\ of\ time.\ However,\ if\ done\ this\ way\ it\ will\ simulate\ data\ usage\n\ over\ price\ changes\ and\ create\ usage\ blocks.\ \n\ \n
comment8.params=
comment8.target=void\ sensorData()
comment8.text=\n\ sensorData\n\ The\ representation\ of\ data\ being\ added\ to\ usage\ records\ as\ it\ is\ detected.\n\ However,\ this\ method\ lacks\ a\ time\ dimension\ and\ would\ typically\ be\ called\n\ concurrently.\ \n
comment9.params=in
comment9.target=void\ addUsage(double)
comment9.text=\n\ addUsage\n\ Adds\ the\ specified\ amount\ of\ power\ to\ the\ present\ block\ of\ usage.\ \n
numComments=37
